<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <title>Title</title>
</head>
<body>

</body>
</html><!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <title>Title</title>
</head>
<body>
<!DOCTYPE HTML>
<!--
	Massively by HTML5 UP
	html5up.net | @ajlkn
	Free for personal and commercial use under the CCA 3.0 license (html5up.net/license)
-->

<html>
<head>
    <title>Project 3 Page</title>
    <meta charset="utf-8" />
    <meta name="viewport" content="width=device-width, initial-scale=1, user-scalable=no" />
    <link rel="stylesheet" href="assets/css/main.css" />
    <noscript><link rel="stylesheet" href="assets/css/noscript.css" /></noscript>
</head>
<body class="is-preload">

<!-- Wrapper -->
<div id="wrapper">

    <!-- Header -->
    <header id="header">
        <a href="index_ko.html" class="logo">Project 1</a>
    </header>

    <!-- Nav -->
    <nav id="nav">
        <ul class="links">
            <li><a href="index_ko.html">Main</a></li>
            <li ><a href="rag_ko.html">Project1</a></li>
            <li class ="active"><a href="voronoi_ko.html"> Project3</a></li>
            <li><a href="metabolic_ko.html "> Project4</a></li>
            <li><a href="account_ko.html "> Project5</a></li>
            <li><a href="mlflow_ko.html"> Project2</a></li>
            <li ><a href="employee_ko.html">Project6</a></li> 

        </ul>
        <div class="language-toggle">
            <a href="voronoi_en.html">English</a>
        </div>
        <ul class="icons">
            <li><a href="http://github.com/sookki0527" class="icon brands fa-github"><span class="label">GitHub</span></a></li>
        </ul>
    </nav>

    <!-- Main -->
    <div id="main">

        <!-- Post -->
        <section class="post">
            <header class="major">

                <p>프로젝트 3</p>
                <h1>델로네 삼각분할: 직접 구현한 분할정복 방식 vs. CGAL 기반 멀티스레딩 기법</h1>
                <p>
                    C++로 직접 구현한 분할정복 기반 델로네 삼각분할 알고리즘과,
                    CGAL 라이브러리를 활용한 멀티스레딩 시각화 방식의 성능을 나란히 비교한 프로젝트입니다.
                </p>


            </header>
            <div class="row">
                <div class="column2">
                    <video width="640" height="480" controls class=" center">
                        <source src="images/voronoi/out.mp4" type="video/mp4">
                        Your browser does not support the video tag.
                    </video>

                </div>
                <br>
                <br>

                <div class="column2">
                    <img src = "./images/voronoi/custom/5.png" style = "width:50%" class = "center">
                </div>
            </div>
            <br>
            <p>
                분할정복 방식을 통해 새로운 LR-에지를 생성하며 병합하는 과정을 구현하기 위해 알고리즘에 대한 심층 분석을 수행했습니다.
                직접 구현한 삼각분할 과정은 SFML을 사용해 시각화하였고,
                CGAL 기반 방식에서는 화면을 네 개의 영역으로 나누어 각 삼각분할 작업을 스레드 풀(thread pool)을 통해 병렬로 처리했습니다.
                공유된 <code>results</code> 컨테이너는 mutex를 사용해 스레드 안전(thread-safe)하게 접근하도록 보호하였습니다.
                이 방식은 OpenGL을 통해 시각화되었습니다.
            </p>




            <p>
                <strong>사용 기술 및 도구:</strong>
                C++17, 사용자 정의 분할정복 알고리즘, 계산기하를 위한 CGAL,
                실시간 시각화를 위한 OpenGL, 보조 렌더링용 SFML,
                스레드 풀과 뮤텍스를 활용한 멀티스레딩 실행 구조.
            </p>

            <h2>1. 분할정복 알고리즘 기반 델로네 삼각분할 직접 구현</h2>

            <h4>Algorithms:</h4>
            <ul>
                <li>Guibas, L. and Stolfi, J., "Primitives for the Manipulation of General Subdivisions and the Computation of Voronoi Diagrams", ACM Transactions on Graphics, Vol.4, No.2, April 1985, pages 74-123.</li>
                <li>http://www.geom.uiuc.edu/~samuelp/del_project.html#acknowledgments</li>

            </ul>

            <h2>델로네 삼각분할 – 분할정복 방식</h2>

            <div class="column2">
                <img src="./images/voronoi/custom/LREdge.png" style="width:100%" class="center">
            </div>
            <br>

            <ol>
                <li>
                    <strong>재귀적 분할 (Recursive Subdivision)</strong><br>
                    정렬된 점 집합을 재귀적으로 더 작은 부분집합으로 나눕니다.
                    각 부분집합에 남은 점이 2개 또는 3개일 경우,
                    2개는 하나의 선분(edge)으로, 3개는 하나의 삼각형(triangle)으로 직접 삼각분할됩니다.
                </li>

                <li>
                    <strong>기본 LR-에지 생성 (Establishing the Base LR-Edge)</strong><br>
                    병합 단계에서는 왼쪽 부분집합의 점과 오른쪽 부분집합의 점을 연결하는 기본 Left-Right(LR) 에지가 생성됩니다.
                    이 에지는 양쪽 부분집합을 잇는 가장 아래쪽의 교차 없는 에지로 설정됩니다.
                </li>

                <li>
                    <strong>후보점 선택 및 병합 (Selecting Valid Candidates & Merging)</strong><br>
                    각 새로운 LR-에지를 기준으로, 좌우 부분집합에서 후보점을 선택합니다.
                    후보점이 **유효(valid)**하려면 아래 조건을 만족해야 합니다:
                    <ul>
                        <li>기존 LR-에지와 후보점 사이의 시계 방향 각도가 180° 미만일 것</li>
                        <li>기존 LR-에지와 후보점으로 구성된 **외접원의 내부에 다음 후보점이 존재하지 않을 것**</li>
                    </ul>
                    조건을 위반하는 경우, 해당 방향의 **LL 또는 RR 에지**는 제거됩니다.<br>
                    이 병합 과정은 상위로 재귀적으로 반복되며,
                    유효한 LR-에지를 계속 추가하고 삼각분할을 병합하여 전체 델로네 삼각분할을 완성합니다.
                </li>
            </ol>

            <h3>코드</h3>



            <pre><code>
template&lt;typename T&gt;
void delaunay&lt;T&gt;::slicingVector(std::vector&lt;Vector2&lt;T&gt;&gt;&amp; vertices)
{
    if (vertices.size() &lt;= 3) {
        createEdges(vertices);
        if (vertices.size() == 3) {
            ...
            _triangles.push_back({
                {a.x, a.y},
                {b.x, b.y},
                {c.x, c.y}
            });
        } else if (vertices.size() == 2) {
            _triangles.push_back({
                {vertices[0].x, vertices[0].y},
                {vertices[1].x, vertices[1].y}
            });
        }
        return;
    }

    size_t mid = vertices.size() / 2;
    std::vector&lt;Vector2&lt;T&gt;&gt; left(vertices.begin(), vertices.begin() + mid);
    std::vector&lt;Vector2&lt;T&gt;&gt; right(vertices.begin() + mid, vertices.end());
    std::cout &lt;&lt; vertices.size() &lt;&lt; std::endl;

    slicingVector(left);
    slicingVector(right);

    std::optional&lt;std::pair&lt;std::pair&lt;T, T&gt;, std::pair&lt;T, T&gt;&gt;&gt; new_LR = potentials(left, right, false);
    std::optional&lt;std::pair&lt;std::pair&lt;T, T&gt;, std::pair&lt;T, T&gt;&gt;&gt; new_LR2 = potentials(left, right, true);
                }

</code></pre>
            <pre><code>
template &lt;typename T&gt;
std::optional&lt;std::pair&lt;std::pair&lt;T, T&gt;, std::pair&lt;T, T&gt;&gt;&gt;
delaunay&lt;T&gt;::potentials(std::vector&lt;Vector2&lt;T&gt;&gt;&amp; vertices1,
                        std::vector&lt;Vector2&lt;T&gt;&gt;&amp; vertices2,
                        bool flipped) {
                    ...
    while (new_LR.has_value()) {

        auto [np1, np2] = new_LR.value();

        ///******************  RR edge  *************************/

        T start = 0;

        std::vector&lt;VertexWithAngle&gt; angle_sorted_vertices_r;

        // Vertices in Right Side
          ...

        std::sort(angle_sorted_vertices_r.begin(), angle_sorted_vertices_r.end(),
                  [](const VertexWithAngle&amp; a, const VertexWithAngle&amp; b) {
                      return a.first &lt; b.first;
                  });

        std::optional&lt;VertexType&gt; next_lr_candidate_r;
        for (auto&amp; candidate : angle_sorted_vertices_r) {
            const TriangleType t(p1, p2, candidate.second);
            start++;

            bool has_inner_point = false;
            for (auto it = angle_sorted_vertices_r.begin() + start; it != angle_sorted_vertices_r.end(); it++) {
                if (t.circumCircleContains(it-&gt;second)) {
                    has_inner_point = true;
                    std::pair&lt;double, double&gt; c = {candidate.second.x, candidate.second.y};

                    _edges.erase(std::remove_if(begin(_edges), end(_edges), [np2, c]
                        (std::pair&lt;std::pair&lt;T, T&gt;, std::pair&lt;T, T&gt;&gt;&amp; j) {
                            return containstwoPoints(j, np2, c);
                        }), end(_edges));
                    break;
                }
            }

            if (!has_inner_point) {
                next_lr_candidate_r = candidate.second;
                break;
                    }
        }

                     ///******************  LL edge  *************************/

                ...
    }
}
</code></pre>

            <h3>주요 관찰 결과</h3>
            <ul>
                <li>초기 점 집합이 x좌표 기준으로 정렬되어 있었기 때문에,
                    생성된 삼각형들이 y축 방향으로 길쭉하게 늘어나는 경향을 보였습니다.</li>
                <li>기본 LR-에지가 y축 기준 가장 낮은 점들에서 시작되다 보니,
                    상단에 있는 일부 점들이 연결되지 않는 현상이 발생했습니다.
                    &rarr; 이를 해결하기 위해 y축을 뒤집고, 반전된 시점에서 새로운 기본 LR-에지를 생성하였습니다.</li>
            </ul>

            <div class="column2">
                <img src="./images/voronoi/custom/9.png" style="width:50%" class="center">
            </div>

            <br><br>

            <h2>2. 멀티스레딩 기반 CGAL 시각화</h2>
            <p>성능 향상을 위해 스레드 풀(thread pool)을 활용한 병렬 처리 구조 구현</p>

            <h3>구현 세부사항</h3>
            <ol>
                <li>CGAL의 2D 델로네 삼각분할 API를 활용하여 계산기하 연산 수행</li>
                <li>OpenGL을 이용하여 삼각분할 시각화</li>
                <li>화면을 4개의 영역으로 분할하고, 각 영역에서 하나의 스레드가 독립적으로 삼각분할을 수행</li>
                <li>각 스레드는 삼각분할 결과를 공유 벡터 <code>results</code>에 기록하며,
                    이 벡터는 mutex를 통해 다중 스레드 접근 시 동기화됨</li>
            </ol>

            <h3>추가 기능</h3>
            <ul>
                <li>움직이는 공(ball)을 도입하여, 공이 통과하는 영역에만 실시간으로 삼각분할이 표시되도록 구현</li>
            </ul>

            <br>

            <h3>코드</h3>


            <pre><code>
void threading(){
    thread_safe_queue&lt;TriangulationTask&gt; task_queue;
    std::mutex results_mutex;

    auto worker = [&]() {
        while (true) {
            TriangulationTask task;
            if (!task_queue.try_pop(task)) break;
            triangulate(task);
            std::lock_guard&lt;std::mutex&gt; lock(results_mutex);
            results.push_back(std::move(task));
        }
    };

    for(int i = 0; i &lt; N; i++){
        TriangulationTask task;
        task.input_file = "data/voronoi" + std::to_string(i+1) + ".cin";

        std::ifstream in(task.input_file);
        std::istream_iterator&lt;Point&gt; begin(in), end;
        task.points = std::vector&lt;Point&gt;(begin, end);
        task_queue.push(task);
    }

    std::vector&lt;std::thread&gt; threads;
    for (int i = 0; i &lt; 4; ++i)
        threads.emplace_back(worker);

    for (auto&amp; t : threads)
        t.join();
}
</code></pre>
            <br>
            <div style="display: flex; justify-content: center; gap: 20px;">
                <img src="./images/voronoi/cgal2.png" style="width: 45%;">
                <img src="./images/voronoi/cgal3.png" style="width: 45%;">
            </div>

            <br>
            <br>
            <h3>More detailed code </h3>
            <ul class="icons alt">

                <li><a href="http://github.com/sookki0527" class="icon brands alt fa-github"><span class="label">GitHub</span></a>
            </ul>
        </section>

    </div>

    <!-- Footer -->
    <footer id="footer">
        <section>
            <form method="post" action="#">
                <div class="fields">
                    <div class="field">
                        <label for="name">Name</label>
                        <input type="text" name="name" id="name" />
                    </div>
                    <div class="field">
                        <label for="email">Email</label>
                        <input type="text" name="email" id="email" />
                    </div>
                    <div class="field">
                        <label for="message">Message</label>
                        <textarea name="message" id="message" rows="3"></textarea>
                    </div>
                </div>
                <ul class="actions">
                    <li><input type="submit" value="Send Message" /></li>
                </ul>
            </form>
        </section>
        <section class="split contact">
            <section class="alt">
                <h3>Address</h3>
                <p>9300 Corporate Blvd Rockville 1341<br />
                    MD 20850 </p>
            </section>
            <section>
                <h3>Phone</h3>
                <p><a href="#">303-875-8115</a></p>
            </section>
            <section>
                <h3>Email</h3>
                <p><a href="#">sookki1205@gmail.com</a></p>
            </section>
            <section>
                <h3>Social</h3>
                <ul class="icons alt">

                    <li><a href="http://github.com/sookki0527" class="icon brands alt fa-github"><span class="label">GitHub</span></a></li>
                </ul>
            </section>
        </section>
    </footer>

    <!-- Copyright -->
    <div id="copyright">
        <ul><li>&copy; Untitled</li><li>Design: <a href="https://html5up.net">HTML5 UP</a></li></ul>
    </div>

</div>

<!-- Scripts -->
<script src="assets/js/jquery.min.js"></script>
<script src="assets/js/jquery.scrollex.min.js"></script>
<script src="assets/js/jquery.scrolly.min.js"></script>
<script src="assets/js/browser.min.js"></script>
<script src="assets/js/breakpoints.min.js"></script>
<script src="assets/js/util.js"></script>
<script src="assets/js/main.js"></script>

</body>
</html>
</div>
</body>
</html>